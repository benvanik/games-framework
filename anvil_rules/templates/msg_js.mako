// Autogenerated by GF - do not modify

goog.provide('${file.namespace}');
% for message in file.messages:
goog.provide('${file.namespace}.${message.name}');
% endfor

% for message in file.messages:
% if message.type_name:
goog.require('${message.type_name}');
% endif
% endfor
goog.require('gf.net.PacketWriter');
goog.require('goog.object');
goog.require('goog.vec.Vec3');
goog.require('goog.vec.Vec4');
goog.require('goog.vec.Mat3');
goog.require('goog.vec.Mat4');
% for const in file.constants:


/**
 * @const
 * @type {number}
 */
${file.namespace}.${const['name']} = ${const['value']};
% endfor
% for message in file.messages:
<% message_type = message.type_name or (file.namespace + '.' + message.name) %>\



/**
% if message.type_name:
 * Wire wrapper object for ${message.type_name}.
% else:
 * Wire message object.
% endif
 * @constructor
 */
${file.namespace}.${message.name} = function() {
% if not message.type_name:
  % for member in message.members:
  /** @type {${member.type.get_closure_type('%s.' % (file.namespace), file)}} */
    % if member.type.is_custom:
  this.${member.name} = new ${member.type.get_custom_name(file)}();
    % else:
  this.${member.name} = ${member.type.default_value};
    % endif
  % endfor
% endif
};
% if not message.type_name:


/**
 * Shared message instance.
 * @type {!${file.namespace}.${message.name}}
 */
${file.namespace}.${message.name}.readInstance = new ${file.namespace}.${message.name}();


/**
 * Shared message instance.
 * @type {!${file.namespace}.${message.name}}
 */
${file.namespace}.${message.name}.writeInstance = new ${file.namespace}.${message.name}();
% endif
% if message.id:


/**
 * Network message ID.
 * @const
 * @type {number}
 */
${file.namespace}.${message.name}.ID = ${message.id};
% endif

\
<%def name="readType(name, type)">\
% if type.is_vec:
  reader.${type.get_read_method()}(${name});
% elif type.is_binary:
  ${name} = reader.readUint8Array(${name});
% elif type.is_array:
<% count_name = 'count_' + name.replace('.', '_') %>\
<% itr_name = 'itr_' + name.replace('.', '_') %>\
  var ${count_name} = reader.readUint32();
  ${name}.length = ${count_name};
  for (var ${itr_name} = 0; ${itr_name} < ${count_name}; ${itr_name}++) {
    % if type.element_type.is_custom:
    ${name}[${itr_name}] = new ${type.element_type.get_custom_name(file)}();
    % endif
    ${readType('%s[%s]' % (name, itr_name), type.element_type)}\
  }
% elif type.is_map:
<% count_name = 'count_' + name.replace('.', '_') %>\
<% itr_name = 'itr_' + name.replace('.', '_') %>\
  ${name} = {};
  var ${count_name} = reader.readUint32();
  for (var ${itr_name} = 0; ${itr_name} < ${count_name}; ${itr_name}++) {
    var map_key, map_value;
    ${readType('map_key', type.key_type)}\
    ${readType('map_value', type.value_type)}\
    ${name}[map_key] = map_value;
  }
% elif type.is_custom:
  if (!${file.namespace}.${type.type}.read(reader, ${name})) {
    return null;
  }
% else:
% if hasattr(type, 'get_closure_cast') and type.get_closure_cast():
  ${name} = ${type.get_closure_cast()} (reader.${type.get_read_method()}());
% else:
  ${name} = reader.${type.get_read_method()}();
% endif
% endif
</%def>
/**
 * Reads a ${message.name} message from the reader.
 * @param {!gf.net.PacketReader} reader Packet reader.
 * @param {${message_type}=} opt_result Object to receive the
 *     results, or null to use the shared instance.
 * @return {${message_type}} The resulting message or null if
 *     an error occurred. If no message was given as a parameter then the result
 *     should be assumed to be transient and not be stored.
 */
${file.namespace}.${message.name}.read = function(reader, opt_result) {
% if message.type_name:
  var result = opt_result || new ${message.type_name}();
% else:
  var result = opt_result || ${file.namespace}.${message.name}.readInstance;
% endif
% if message.id:
  // Assumes that a ${file.namespace}.${message.name}.ID has already been read
% endif
% for member in message.members:
${readType(name='result.' + member.name, type=member.type)}\
% endfor
  return result;
};

\
<%def name="writeType(name, type)">\
% if type.is_binary:
  writer.writeUint8Array(${name});
% elif type.is_array:
  writer.writeUint32(${name}.length);
<% itr_name = 'itr_' + name.replace('.', '_') %>\
  for (var ${itr_name} = 0; ${itr_name} < ${name}.length; ${itr_name}++) {
    var el = ${name}[${itr_name}];
    ${writeType('el', type.element_type)}\
  }
% elif type.is_map:
  writer.writeUint32(goog.object.getCount(${name}));
  for (var map_key in ${name}) {
    var map_value = ${name}[map_key];
    ${writeType('map_key', type.key_type)}\
    ${writeType('map_value', type.value_type)}\
  }
% elif type.is_custom:
  if (!${file.namespace}.${type.type}.write(writer, ${name})) {
    return false;
  }
% else:
  writer.${type.get_write_method()}(${name});
% endif
</%def>
/**
 * Writes a ${message.name} message to the writer.
 * @param {!gf.net.PacketWriter} writer Packet writer.
 * @param {!${message_type}} value Object to write.
 * @return {boolean} Whether the message was written successfully.
 */
${file.namespace}.${message.name}.write = function(writer, value) {
% for member in message.members:
% if member.type.is_vec:
  // TODO(benvanik): verify size of ${member.name} (proper length/etc)
% elif member.type.is_binary:
  // TODO(benvanik): verify size of ${member.name} (proper length/etc)
% elif member.type.is_array:
  // TODO(benvanik): verify size of ${member.name} (proper count/etc)
% elif member.type.is_map:
  // TODO(benvanik): verify size of ${member.name} (proper count/etc)
% elif member.type.is_string:
  // TODO(benvanik): verify size of ${member.name} (proper length/etc)
% endif
% endfor
% if message.id:
  writer.writeUint8(${file.namespace}.${message.name}.ID);
% endif
% for member in message.members:
${writeType(name='value.' + member.name, type=member.type)}\
% endfor
  return true;
};


/**
 * Creates a new message data value.
% for member in message.members:
 * @param {${member.type.get_closure_type('%s.' % (file.namespace), file)}} ${member.name} ${member.name}.
% endfor
 * @return {ArrayBuffer} Message bytes, or null if an error occurred.
 */
${file.namespace}.${message.name}.createData = function(\
% for i, member in enumerate(message.members):
${member.name}\
% if i != len(message.members) - 1:
, \
% endif
% endfor
) {
  var writer = ${file.namespace}.packetWriter_;
  var messageInstance = ${file.namespace}.${message.name}.writeInstance;
% for member in message.members:
% if member.type.is_vec:
  ${member.type.name}.setFromArray(messageInstance.${member.name}, ${member.name});
% else:
  messageInstance.${member.name} = ${member.name};
% endif
% endfor
  if (!${file.namespace}.${message.name}.write(writer, messageInstance)) {
    writer.drop();
    return null;
  }
  return writer.finish();
};
% endfor


/**
 * Shared packet writer.
 * @private
 * @type {!gf.net.PacketWriter}
 */
${file.namespace}.packetWriter_ = new gf.net.PacketWriter();
